# FEATURE CLASS CONVERSION FROM ZM POLYGONS TO POLYGONS
# FeatureClassConversion. Conversion tools/To shapefile/feature class to shapefile
# environments: disable M coordinate, disable Z coordinate

# important: if already web mercator projected: do not recalculate hectares of the polygons because it is not UTM projected

# rebuild potential/available/costs because of artifacts in slopes after spatial join
# new approach: zonal stats as table for conifers, broadleaved, mixed and shrubs, dehesas

# import PESERA (soil erosion risk) and SLOPES rasters into gdb. check projections from web mercator for zonal stats
# import ORCDRC30_01 (soil organic carbon) in units comparable to chrisgas matrix reviewed
# import AGB (JRC forest increment raster) + NPP (net primary productivity raster)
# import NPP > 0 (see doc): units Tg/yrm2

# simplify raster names for easier scripts 
# AGB_All_FF_Full_ISE_BS = AGB (units: Mg ha-1 yr-1) this layer is used for all the forestry but shrubs potential biomass computation
# EU8_slope_mask = slope (percent rise)
# npp2010_LAEA_gt0 = npp (Tg*a-1*km-2): to convert to Tg yr-1 ha-1 divide by 100 (1 km2 = 100 ha)
    # sent mail to wdc@dlr.de to check units because Tg*a-1*km-2 = 10**4 t*yr-1*ha-1 and g*m-2*d-1= 3.65 t*yr-1*ha-1
    # trying to convert units to t*yr-1*ha-1 does not seem to yield reasonable values
    # this raster is only used for the Shrubs layer
# ORCDRC30_01 = orgc (organic carbon 30 cm depth g/kg = º/ºº = 0.1* % (comparable to OCTOP*0.1, the database used in previous BIORAISE)

### INTEGRATION OF RASTER DATA INTO SHAPEFILE POLYGON DATA
## Two approaches for integrating raster data into vector data. 
## 1. Zonal statistics as table + Table import + Join Field (sometimes tricky because of the identifiers)
## 2. Spatial join. First step: raster to point

#1.
## ZONAL STATS AS TABLE (final version used this approach November 2018)
# it is very important to check the Identifier to be used in the zonal stats as table and in the following Join Field
# ID in the zonal statistics is generated after processing to match the number of rows in the zonal table
# if the identifiers are with the same name, this can generate confusion in the Join Field
# VIP: the second column in the zonal table contains the Identifier in the Shapefile layer (ID to use in the Join Field operation)
# zonal stats from rasters: PESERA, ORCDRC30_01, AGB, NPP, slope
# if raster is integer, more statistics are possible
# we generate all possible stats with the option "ALL" (save the dbfs to check more info about min/max/range/sd)

import arcpy  
import os  
import re
from arcpy import env
from arcpy.sa import *
arcpy.env.workspace = r"E:\TFS_nov_forestry\forestry.gdb"
arcpy.env.overwriteOutput = True
# arcpy.env.extent = "MINOF" # check what option is best. https://pro.arcgis.com/es/pro-app/tool-reference/environment-settings/output-extent.htm
destination_path = r"E:\TFS_nov_forestry\forestry.gdb"
fcList = arcpy.ListFeatureClasses()
for fc in fcList:    
    #featureClasses = arcpy.ListFeatureClasses("*XX*","All") # if we want to select only certain features
    rasters = arcpy.ListRasters()
    for raster in rasters:
    	outTable = os.path.join(destination_path, fc + "_" + raster + ".dbf")
        try:
    	    arcpy.gp.ZonalStatisticsAsTable_sa(fc, "OBJECTID", raster,outTable,"DATA","MEAN") # important Identifier
        except:
            print fc
            #print raster
            continue
	   
	   # we also compute the SD statistic for the slopes and join it with the name of Sd_slope
	   # we compute a new column of Avgsd_slop being Avg_slope + Sd_slope (in absolute values)
import arcpy  
import os  
import re
outWorkspace = r"E:\TFS_nov_forestry\forestry.gdb"
arcpy.env.workspace = outWorkspace  
arcpy.env.overwriteOutput = True 
tbList = arcpy.ListTables("*all*","All")
for tb in tbList:    
    #print(tb)
    # table = broad_slopeall (name type)
    name = "Avgsd_slop"
    expression = "!MEAN!+!STD!"
    #print name 
    try:
        arcpy.AddField_management(tb, name, "FLOAT","", "", "", name, "NULLABLE", "NON_REQUIRED", "")   
        arcpy.CalculateField_management(tb, name, expression, "PYTHON_9.3", "") 
    except:
        continue
	    
	   # note: in last review of forestry, I ran batch processes and named the fields like Avg_agb, Avg_npp...
	   # consider coding for other names (like name1 = "Avg_" + name) 
	   # consider other statistics (if the raster is integer, we can have variety, etc.) see documentation
	     # MEAN_STD —Se calculan las estadísticas de valor medio y de desviación estándar (looks useful): check

### MEANINGFUL NAME # review code depending on case need to change the name, name2, name3 objects
import arcpy  
import os  
import re
outWorkspace = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.workspace = outWorkspace  
arcpy.env.overwriteOutput = True 
tbList = arcpy.ListTables()
for tb in tbList:    
    #print(tb)
    # table = broad_npp (name type)
    name = tb.split('_')[0].split('.dbf')[0] # name = broad (it is possible to combine split function like .split('X').split('Y')[0])
    #print name # e.g. name = broad
    name2 = tb.split('_')[1].split('dbf')[0]
    print name2 # e.g. name2= agb
    name3 = "Avg_" + name2
        try:
            arcpy.AddField_management(fc, name3, "FLOAT","", "", "", name, "NULLABLE", "NON_REQUIRED", "")   
            arcpy.CalculateField_management(fc, name3, "'!MEAN!'", "PYTHON_9.3", "") 
        except:
            continue
	    
	   # note: in last review of forestry, I ran batch processes and named the fields like Avg_agb, Avg_npp...
	   # consider coding for other names (like name1 = "Avg_" + name) 
	   # consider other statistics
	    
### JOIN FIELD
import os
arcpy.env.workspace = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
ws = arcpy.env.workspace
fcl = arcpy.ListFeatureClasses()
tbl = arcpy.ListTables("dehesas_npp*","All")
# table name = dehesas_npp
#print tbl
for table in tbl:
    basename = table.split("_")[0] #split name of tables and only take the first word as a basename # dehesas
    basename1 = table.split("_")[1] #split name of tables and only take the second word as a basename # npp
    basename2 = table.split("_")[0] + "_av" # check if we need to add .shp
    print basename2 # not needed: print = dehesas_av
    inFeatures = os.path.join(ws, basename2) #The table or feature class to which the join table will be joined. (SHAPEFILE IN OUR CASE: CORINE LAND COVER)
    joinField = "OBJECTID" #The field in the input table on which the join will be based. (ORIGINAL IDENTIFIER FROM SHAPEFILE USED IN THE ZONAL STATISTICS TOOL)
    joinTable = os.path.join(ws, basename + "_" + basename1) #The table to be joined to the input table. (table generated in zonal stats as table)
    join_field = "OBJECTID_1" #The field in the join table that contains the values on which the join will be based. 
    #VIP: CHECK IDENTIFIER IN ZONAL STATS TABLE: IT IS NOT THE ROW NUMBER IDENTIFIER (MOST LEFT COLUMN), BUT THE SECOND (CORRESPONDING TO THE ORIGINAL SHAPEFILE IDENTIFIER)
    #VIP: might have change the identifier if the new identifier in the zonal stats table is the same name as it was in the shapefile: that's why the corresponding identifier between shapefile and the table is OBJECTID_1
    #JoinField "JoinField_management (in_data, in_field, join_table, join_field, {fields})"
    try:
        arcpy.JoinField_management(inFeatures , joinField , joinTable , join_field, fieldList)
    except:
        print inFeatures
	continue
	
# joinfield for slope mean+std = Avgsd_slop 
import arcpy  
import os  
import re
outWorkspace = r"E:\TFS_nov_forestry\forestry.gdb"
arcpy.env.workspace = outWorkspace  
arcpy.env.overwriteOutput = True 
tbList = arcpy.ListTables("*all*","All")
for tb in tbList:    
    basename = tb.split("_")[0] #split name of tables and only take the first word as a basename # dehesas
    basename1 = tb.split("_")[1] #split name of tables and only take the second word as a basename # npp
    basename2 = tb.split("_")[0] + "_av" # check if we need to add .shp
    #print basename2 # not needed: print = dehesas_av
    inFeatures = os.path.join(ws, basename2) #The table or feature class to which the join table will be joined. (SHAPEFILE IN OUR CASE: CORINE LAND COVER)
    joinField = "OBJECTID" #The field in the input table on which the join will be based. (ORIGINAL IDENTIFIER FROM SHAPEFILE USED IN THE ZONAL STATISTICS TOOL)
    joinTable = os.path.join(ws, basename + "_" + basename1) #The table to be joined to the input table. (table generated in zonal stats as table)
    join_field = "OBJECTID_1" #The field in the join table that contains the values on which the join will be based. 
    #VIP: CHECK IDENTIFIER IN ZONAL STATS TABLE: IT IS NOT THE ROW NUMBER IDENTIFIER (MOST LEFT COLUMN), BUT THE SECOND (CORRESPONDING TO THE ORIGINAL SHAPEFILE IDENTIFIER)
    #VIP: might have change the identifier if the new identifier in the zonal stats table is the same name as it was in the shapefile: that's why the corresponding identifier between shapefile and the table is OBJECTID_1
    #JoinField "JoinField_management (in_data, in_field, join_table, join_field, {fields})"
    fieldList = ['Avgsd_slop','OBJECTID_1']
    try:
        arcpy.JoinField_management(inFeatures , joinField , joinTable , join_field, fieldList)
    except:
        print inFeatures
	continue

## checked that all is ETRS89 LAEA projected 
# check hectares
import arcpy
import os
top_folder = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.workspace = top_folder
fcl = arcpy.ListFeatureClasses()
for fc in fcl:
    try:
        arcpy.AddField_management(fc,"ha_NN","Double")
        expression = "{0}".format("!SHAPE.area@HECTARES!")        
        arcpy.CalculateField_management(fc, "ha_NN", expression, "PYTHON", )
    except:
        print fc
        continue

### POTENTIAL BIOMASS (T/YR)
## with NPP and AGB Paloma generates potential biomass (in t/yr) in excel tables
# ? conditional if AGB is 0, take NPP? check how this is done!
# VIP: first change values in Avg_npp column according to NPP units (1 km2 = 100 hectares)
# i.e., divide by 100 because km2 is in the denominator
# VIP: introduce in the conditional what is done in excel (standardize = dividing by the mean)
import os
import arcpy
import itertools
import csv
folderPath = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 
fcLst = arcpy.ListFeatureClasses()
for fc in fcLst:
    fieldName = "NPPu"
    arcpy.AddField_management(fc, fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "") 
    expression = "!Avg_npp!/100"
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3")
    except:
        print fc
        continue
# VIP: check tables to decide whether to apply or not this conditional. maybe not comparable NPP/AGB values
# this is not needed: we only use AGB in forestry layers and NPP in shrubs (need to find out about the NPP units for this)
import os
import arcpy
import itertools
import csv
folderPath = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 
fcLst = arcpy.ListFeatureClasses()
for fc in fcLst:   
    fieldName = "cNPPAGB"
    arcpy.AddField_management(fc, fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "") 
    expression = "CONDITIONAL(!Avg_agb!, !NPPu!)"
    codeblock = """def CONDITIONAL(valAGB, valNPP):
       if (valAGB == 0) and (valNPP != 0):
           fieldname = valNPP 
           return fieldname
       elif (valAGB == 0) and (valNPP == 0):
           fieldname = 0          # VIP: use numpy return the mean of the Avg_AGB not considering rows with 0 and then expression to divide each row by this mean?
           return fieldname
       elif (valAGB is None) and (valNPP is None):
           fieldname = None
           return fieldname
       elif (valAGB is None) and (valNPP is not None):
           fieldname = valNPP
           return fieldname
       else: 
           fieldname = valAGB
           return fieldname # this is when AGB is not 0 and not Null
       """
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue
	
# shrubs use NPP, rest of forestry use AGB # 
# where NPP = null or 0, take fix productivity from Chrisgas ## add 30thNov this fix productivity in the code
# where no 0 = normalize (compute the mean and divide by it every row)

## AVAILABLE restrictions orgc (soil organic carbon 30cm depth) + PESERA (soil erosion risk): not in Turkey nor Croatia
# introduce if/else statements considering nut2 to not apply pesera in turkey/croatia
# create field potential the same for all layers first
import os
import arcpy
import itertools
import csv
folderPath = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 
fcLst = arcpy.ListFeatureClasses("Shrub*","All")
for fc in fcLst:
    fieldName = "tyr"
    arcpy.AddField_management(fc, fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "") 
    expression = "!thayrplus!"
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3")
    except:
        print fc
        continue
	
import os
import arcpy
import itertools
import csv
folderPath = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 
fcLst = arcpy.ListFeatureClasses("dehesas*","All")
for fc in fcLst:
    fieldName = "tyr"
    arcpy.AddField_management(fc, fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "") 
    expression = "!Mgyha!"
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3")
    except:
        print fc
        continue
	
	
import os
import arcpy
import itertools
import csv
folderPath = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 
fcLst = [fc for fc in arcpy.ListFeatureClasses() if fc.startswith('conif') or os.path.splitext(fc)[0].startswith('mix') or os.path.splitext(fc)[0].startswith('broad')]
#print fcLst
for fc in fcLst:
    fieldName = "tyr"
    arcpy.AddField_management(fc, fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "") 
    expression = "!Pot_tyr!"
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3")
    except:
        print fc
        continue
	
# ENVIRONMENTAL CONSTRAINTS PES ORCDRC01
# soil organic carbon restriction (30thNov check coefficients in matrix if they are the same for forest and shrubs!!)
# all countries have orgc values
# VIP: Select what slope to use (as Avg_slope smoothes the slopes in steep areas, maybe the Avgsd_slop field, considering MEAN+STD is more suitable)
import arcpy  
import os  
from arcpy import env
arcpy.env.workspace=r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.overwriteOutput = True 
fcList = arcpy.ListFeatureClasses()
#print fcList
for fc in fcList:
    fieldName = "avorgc"
    arcpy.AddField_management(fc,"avorgc","FLOAT","", "", "", "avorgc", "NULLABLE", "NON_REQUIRED", "") 
    expression = "potential(float(!tyr!), float(!Avg_slope!), float(!Avg_orgc!))" # potential biomass names
    codeblock = """def potential(valPotential_tyr, valSlope, orgc):
       if (valSlope<20):
           if orgc < 1: 
               return 0
           elif orgc < 2: 
               rorg = valPotential_tyr * 0.4
               return rorg
           else: 
               rorg = valPotential_tyr * 0.6
               return rorg
       elif (valSlope<60):
           if orgc < 1: 
               return 0
           elif orgc < 2: 
               rorg = valPotential_tyr * 0.3
               return rorg
           else: 
               rorg = valPotential_tyr * 0.5
               return rorg
       else:
           return 0"""
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

# PESERA 
##avpesera 
import arcpy  
import os  
from arcpy import env
arcpy.env.workspace=r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.overwriteOutput = True 
#fcs = [fc for fc in arcpy.ListFeatureClasses() if not fc.endswith('orcdrc1.shp')] # consider separating Turkey/Croatia
fcs = arcpy.ListFeatureClasses()
print fcs
for fc in fcs:
    fieldName = "avpes"
    arcpy.AddField_management(fc,"avpes","FLOAT","", "", "", "avpes", "NULLABLE", "NON_REQUIRED", "") # this will be the final available resources NEEDS CALCULATEFIELD MANAGEMENT AFTER SOIL LOSS RESTRICTIONS AND CARBON RESTRICTIONS
    expression = "AVPES(float(!tyr!), float(!Avg_slope!), float(!Avg_pes!))" #30thNov change potential field!!
    codeblock = """def AVPES(valPotential_tyr, valSlope, valpesera):
       if valpesera is not None:
           if (valSlope<20):
               if valpesera < 2: 
                   ravpes = valPotential_tyr * 0.6
                   return ravpes
               elif valpesera < 10: 
                   ravpes = valPotential_tyrv * 0.4
                   return ravpes
               else: 
                   return 0
           elif (valSlope<60):
               if valpesera < 2: 
                   rvavpes = valPotential_tyr * 0.5    
                   return ravpes
               elif valpesera < 10: 
                   ravpes = valPotential_tyr * 0.3
                   return ravpes
               else: 
                   return 0
           else:
               return 0
        else:	   
	    ravpes = None
	    return ravpes"""
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

## more restrictive considering pesera erosion risk
import arcpy
arcpy.env.workspace=r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.overwriteOutput = True 
fcs = arcpy.ListFeatureClasses()
#print fcList
for fc in fcs:
    fieldName = "avplus"
    name = "avplus"
    arcpy.AddField_management(fc,"avplus","FLOAT","", "", "", "avplus", "NULLABLE", "NON_REQUIRED", "")
    expression = "available(float(!avorgc!), float(!avpes!), float(!Avg_pes!))"
    codeblock = """def available(valavorgc, valavloss, valpesera):
        if valpesera is not None:
            if (valavorgc<valavloss):
                return valavorgc
            else:
                return valavloss
        else:
            av = valavorgc  
            return av"""
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

# now the AVAILABLE BIOMASS (T/YR) is avplus (rename after costs)
### COSTS
import arcpy
arcpy.env.workspace=r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.overwriteOutput = True 
featureClasses = arcpy.ListFeatureClasses()
matriz = [["Shrub_av.shp",47.36292204, 0.0299220385], ["broad_av.shp", 47.38296986, 0.049969856], ["conif_av.shp",47.3631926,0.0301926], ["mix_av.shp",47.36531403, 0.03231403], ["dehesas_av.shp",47.38942963, 0.056429635]] ##30thNov coefficients!!!
for i in range (0,3):
    inTable = matriz[i][0]
    coef1 = matriz[i][1]
    coef2 = matriz[i][2]
    fieldName = "cost"
    field_names = [f.name for f in arcpy.ListFields(inTable)]
    slope_field = "Avg_slope"
    #biomass = "avplus"
    arcpy.AddField_management(inTable,"cost","FLOAT","", "", "", "cost", "NULLABLE", "NON_REQUIRED", "") 
    #expression = 'float(float(' + str(coef1) + ') - float(!avplus!* ' + str(coef2) + '))'
    #expression = '1'
    expression = "IgnoreZero(float(!avplus!), float(!Avg_slope!), float(coef1), float(coef2))"
    codeblock = """def IgnoreZero(val, valSlope, c1, c2):
       if (val==0):
           return 0
       else:
           r=c1 - val * c2
           if (valSlope>20):
               return r*1.3
           else:   
               return r"""
    arcpy.CalculateField_management(inTable, fieldName, expression, "PYTHON_9.3", codeblock)

## costs array: 
Shrub	47.3631926	0.0301926
Broadleaved	47.36531403, 0.03231403
Conifers	47.36385994, 0.030859944
Mixed	47.36321003, 0.03021003
Dehesas	47.38296986, 0.049969856

### MAKE A COPY. RENAME FIELDS AVPLUS for Shrubs: avplus, Dehesas:Mgyha, avMg, costfix, conifers/broad/mixed: Av_tyr
## dropfields/project to WebMercator/ send to TFS
## Change of name 
import arcpy
arcpy.env.workspace=r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.overwriteOutput = True 
featureClasses = arcpy.ListFeatureClasses("dehesas*","All")
for fc in featureClasses:
    fieldName = "avMg"
    try:
        arcpy.AddField_management(fc,fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "") 
        expression = 'float(!avplus!)'
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3")
    except:
        print fc
        continue
	
import arcpy
arcpy.env.workspace=r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.overwriteOutput = True 
featureClasses = arcpy.ListFeatureClasses("dehesas*","All")
for fc in featureClasses:
    fieldName = "costfix"
    try:
        arcpy.AddField_management(fc,fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "") 
        expression = 'float(!cost!)'
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3")
    except:
        print fc
        continue

import arcpy
arcpy.env.workspace=r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.overwriteOutput = True 
fcLst = [fc for fc in arcpy.ListFeatureClasses() if fc.startswith('conif') or os.path.splitext(fc)[0].startswith('mix') or os.path.splitext(fc)[0].startswith('broad')]
for fc in fcLst:
    fieldName = "Av_tyr"
    try:
        arcpy.AddField_management(fc,fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "") 
        expression = 'float(!avplus!)'
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3")
    except:
        print fc
	
## dropfields
import arcpy
import os
import glob
arcpy.env.workspace = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb" 
fclst = arcpy.ListFeatureClasses()
arcpy.env.overwriteOutput = True
for fc in fclst:
    fcName = fc
    #print(fc)
    arcpy.env.overwriteOutput = True
    output = fc.split(".shp")[0] +"_drop.shp"
    print output
    out_workspace = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry" 
    out_featureclass = os.path.join(out_workspace, 
                                    os.path.splitext(output)[0])
    print out_featureclass
    dropFields = ["tyrplus","OBJECTID_1", "OBJECTID_12","OBJECTID_12_13","OBJECTID_12_13_14", "OBJECTID_12_13_14_15","ha_NN", "tyr", "Avg_agb", "Avg_slope", "avpes", "avorgc", "Avg_npp", "Avg_orgc", "NPPu", "cNPPAGB"]
    try:
        arcpy.CopyFeatures_management(fc, out_featureclass)
        arcpy.DeleteField_management(out_featureclass, dropFields)
    except:
        print fc + "bad"
        continue
	
## project to google web mercator

## STATISTICS BY NUT2: for the original ones (with the same names for potential biomass (tyr) and available biomass (avplus)
# quicker in excel with dynamic tables
import os
import arcpy
import numpy
folderPath = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 
fcLst = arcpy.ListFeatureClasses()
## potential stats  
for fc in fcLst:
    fieldName = "pNUT"
    fieldName1 = "dNUT"
    fieldName2 = "haNUT"
    arcpy.AddField_management(fc,fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "")  
    arcpy.AddField_management(fc,fieldName1,"FLOAT","", "", "", fieldName1, "NULLABLE", "NON_REQUIRED", "")
    arcpy.AddField_management(fc,fieldName2,"FLOAT","", "", "", fieldName2, "NULLABLE", "NON_REQUIRED", "")
    expression = "miFunc(!NUTS_ID!, !tyr!, !avplus!, !ha!)"
    codeblock = """def miFunc(miNut2, mipot, midisp, misup):
        sumtDMpNUT = numpy.sum([r[0] for r in arcpy.da.SearchCursor(fc,["tyr", "NUTS_ID"], where_clause="NUTS_ID like '" + miNut2 + "'")])   
        return sumtDMpNUT"""
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

## available stats   
import os
import arcpy
import numpy
folderPath = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 
fcLst = arcpy.ListFeatureClasses()
for fc in fcLst:
    fieldName1 = "dNUT"
    expression = "miFunc(!NUTS_ID!, !tyr!, !avplus!, !ha!)"
    codeblock = """def miFunc(miNut2, mipot, midisp, misup):
        sumtDMdNUT = numpy.sum([r[0] for r in arcpy.da.SearchCursor(fc,["avplus", "NUTS_ID"], where_clause="NUTS_ID like '" + miNut2 + "'")])   
        return sumtDMdNUT"""
    try:
        arcpy.CalculateField_management(fc, fieldName1, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

## surface stats  
import os
import arcpy
import numpy
folderPath = r"C:\Users\Eva\Desktop\forestryfix\TFS_nov_forestry\forestry.gdb"
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 
fcLst = arcpy.ListFeatureClasses()
for fc in fcLst:
    fieldName2 = "haNUT"
    expression = "miFunc(!NUTS_ID!, !tyr!, !avplus!, !ha!)"
    codeblock = """def miFunc(miNut2, mipot, midisp, misup):
        sumtDMdNUT = numpy.sum([r[0] for r in arcpy.da.SearchCursor(fc,["ha", "NUTS_ID"], where_clause="NUTS_ID like '" + miNut2 + "'")])   
        return sumtDMdNUT"""
    try:
        arcpy.CalculateField_management(fc, fieldName2, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

#2. DONE IN SEPTEMBER/OCTOBER. 
### RASTER TO POINT

import arcpy
from arcpy import env
env.workspace = r"F:\DEM\slope\masks"

rasterlst = arcpy.ListRasters()
#print rasterlst

for raster in rasterlst: 
    inRaster = raster
    outPoint = raster.split(".tif")[0] + ".shp"
    #print outPoint
    field = "VALUE"
    try:
        arcpy.RasterToPoint_conversion(inRaster, outPoint, field)
    except:
        print raster
        continue

##SPATIAL JOIN (check) 
import arcpy
import os
workspace = r"F:\NPP_biomass\NPP_WDR\slopepts_countries\slopes_ok"
outWorkspace = r"F:\NPP_biomass\NPP_WDR\slopepts_countries\spatial_NUT2"
# Want to join NUT2 to slopes and calculate the mean slope for each polygon in NUT2
#Run the Spatial Join tool, using the defaults for the join operation and join type
arcpy.SpatialJoin_analysis(targetFeatures, joinFeatures, outfc, "#", "#", fieldmappings)

### MERGE FILES
import arcpy
from arcpy import env

arcpy.env.workspace = r"F:\NPP_biomass\NPP_WDR\shrub_countries_matrix"

fclst = arcpy.ListFeatureClasses()

for fc in fclst:
    countryname = fc.split("_shrub_")[0]
    #feature classes to be merged
    fc1 = countryname + "_shrub_pesera.shp"
    fc2 = countryname + "_shrub_ordcrd.shp"
    try:
        fieldMappings = arcpy.FieldMappings()
        fieldMappings.addTable(fc1)
        fieldMappings.addTable(fc2)
        output = "F:/bioraise/NPP_biomass/NPP_WDR/shrub_countries_matrix/merge_orcdrc_pesera" + "/" + "merge_"+ fc1 
        print output
        #arcpy.Merge_management([oldStreets, newStreets], output, fieldMappings)
    except:
        #print fc, "baaad"
        continue
	
### CHECK RASTER PROPERTIES
import arcpy
from arcpy import env
env.workspace = r"F:\DEM\slope\masks"

rasterlst = arcpy.ListRasters()
#print rasterlst

for raster in rasterlst: 
    props = ['MINIMUM', 'MAXIMUM', 'MEAN', 'STD', 'ALLNODATA', 'ANYNODATA', 'UNIQUEVALUECOUNT']  
    for prop in props:  
        try:  
            print "{0}: {1}".format(prop, arcpy.GetRasterProperties_management(raster, prop))  + raster
        except Exception as e:  
            print "{0}: {1}".format(prop, e) + raster + " baaad"
            continue  

# ENVIRONMENTAL CONSTRAINTS PES ORCDRC01
import arcpy  
import os  
from arcpy import env
arcpy.env.workspace=r"E:\new_shrub\Potencial" 
arcpy.env.overwriteOutput = True 

fcList = arcpy.ListFeatureClasses()
#print fcList

for fc in fcList:
    fieldName = "avorgc"
    arcpy.AddField_management(fc,"avorgc","FLOAT","", "", "", "avorgc", "NULLABLE", "NON_REQUIRED", "") 
    expression = "potential(float(!tyrplus!), float(!slope!), float(!orcdrc01!))" # check with slop field when ready
    codeblock = """def potential(valty, valSlope, orgc):
       if (valSlope<20):
           if orgc < 1: 
               return 0
           elif orgc < 2: 
               rorg = valty * 0.4
               return rorg
           else: 
               rorg = valty * 0.6
               return rorg
       elif (valSlope<60):
           if orgc < 1: 
               return 0
           elif orgc < 2: 
               rorg = valty * 0.3
               return rorg
           else: 
               rorg = valty * 0.5
               return rorg
       else:
           return 0"""
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

# PESERA 
##avpesera 
import arcpy  
import os  
from arcpy import env
arcpy.env.workspace=r"E:\new_shrub\Potencial"   
arcpy.env.overwriteOutput = True 

fcs = [fc for fc in arcpy.ListFeatureClasses() if not fc.endswith('orcdrc1.shp')]
print fcs
for fc in fcs:
    fieldName = "avpes"
    arcpy.AddField_management(fc,"avpes","FLOAT","", "", "", "avpes", "NULLABLE", "NON_REQUIRED", "") # this will be the final available resources NEEDS CALCULATEFIELD MANAGEMENT AFTER SOIL LOSS RESTRICTIONS AND CARBON RESTRICTIONS
    expression = "AVPES(float(!tyrplus!), float(!slope!), float(!pes!))"
    codeblock = """def AVPES(valty, valSlope, soileros):
       if (valSlope<20):
           if soileros < 2: 
               rsoileros = valty * 0.6
               return rsoileros
           elif soileros < 10: 
               rsoileros = valty * 0.4
               return rsoileros
           else: 
               return 0
       elif (valSlope<60):
           if soileros < 2: 
               rsoileros = valty * 0.5    
               return rsoileros
           elif soileros < 10: 
               rsoileros = valty * 0.3
               return rsoileros
           else: 
               return 0
       else:
           return 0"""
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

## more restrictive considering pesera erosion risk
import arcpy
arcpy.env.workspace=r"E:\new_shrub\Potencial"  
arcpy.env.overwriteOutput = True 

fcs = [fc for fc in arcpy.ListFeatureClasses() if not fc.endswith('orcdrc1.shp')]
#print fcList

for fc in fcs:
    
    fieldName = "avplus"
    name = "avplus"
    arcpy.AddField_management(fc,"avplus","FLOAT","", "", "", "avplus", "NULLABLE", "NON_REQUIRED", "")
    expression = "available(float(!avorgc!), float(!avpes!), float(!pes!))"
    codeblock = """def available(valavorgc, valavloss, valpesera):
        if valpesera is not None:
            if (valavorgc<valavloss):
                return valavorgc
            else:
                return valavloss
        else:
            av = valavorgc  
            return av"""
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue


### COSTS

import arcpy
arcpy.env.workspace=r"E:\new_shrub\Available"  
arcpy.env.overwriteOutput = True 

featureClasses = arcpy.ListFeatureClasses()

matriz = [["sp_shrub_merge.shp",47.36292204, 0.0299220385], ["cr_shrub_orcdrc1.shp", 47.38296986, 0.049969856], ["fr_shrub.shp",47.3631926,0.0301926], ["gr_shrub.shp",47.36385994, 0.030859944], ["it_shrub.shp",47.36321003, 0.03021003], ["pt_shrub.shp",47.36531403, 0.03231403], ["sl_shrub.shp",47.38942963, 0.056429635], ["tu_shrub_orcdrc1.shp",47.35536757, 0.022367565]] ##coefficients!!!

for i in range (0,7):
    inTable = matriz[i][0]
    coef1 = matriz[i][1]
    coef2 = matriz[i][2]
    fieldName = "cost"
    field_names = [f.name for f in arcpy.ListFields(inTable)]
    slope_field = "slope"
    #biomass = "avplus"
    arcpy.AddField_management(inTable,"cost","FLOAT","", "", "", "cost", "NULLABLE", "NON_REQUIRED", "") 
    #expression = 'float(float(' + str(coef1) + ') - float(!avplus!* ' + str(coef2) + '))'
    #expression = '1'
    expression = "IgnoreZero(float(!avplus!), float(!slope!), float(coef1), float(coef2))"
    codeblock = """def IgnoreZero(val, valSlope, c1, c2):
       if (val==0):
           return 0
       else:
           r=c1 - val * c2
           if (valSlope>20):
               return r*1.3
           else:   
               return r"""
    arcpy.CalculateField_management(inTable, fieldName, expression, "PYTHON_9.3", codeblock)


## costs array: 
Francia	47.3631926	0.0301926
Portugal	47.36531403, 0.03231403
Grecia	47.36385994, 0.030859944
Italia	47.36321003, 0.03021003
Croacia	47.38296986, 0.049969856
Eslovenia	47.38942963, 0.056429635
Turquia	47.35536757, 0.022367565
España	47.36292204, 0.029922038


## stats 
import os
import arcpy
import numpy
folderPath = r"E:\new_shrub\Available" 
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 

fcLst = arcpy.ListFeatureClasses()

## potential stats  
for fc in fcLst:
    fieldName = "pNUT"
    fieldName1 = "dNUT"
    fieldName2 = "haNUT"
    arcpy.AddField_management(fc,fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "")  
    arcpy.AddField_management(fc,fieldName1,"FLOAT","", "", "", fieldName1, "NULLABLE", "NON_REQUIRED", "")
    arcpy.AddField_management(fc,fieldName2,"FLOAT","", "", "", fieldName2, "NULLABLE", "NON_REQUIRED", "")
    expression = "miFunc(!NUT2d!, !tyrplus!, !avplus!, !ha!)"
    codeblock = """def miFunc(miNut2, mipot, midisp, misup):
        sumtDMpNUT = numpy.sum([r[0] for r in arcpy.da.SearchCursor(fc,["tyrplus", "NUT2d"], where_clause="NUT2d like '" + miNut2 + "'")])   
        return sumtDMpNUT"""
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

## available stats   
import os
import arcpy
import numpy
folderPath = r"E:\new_shrub\Available" 
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 

fcLst = arcpy.ListFeatureClasses()

for fc in fcLst:
    fieldName1 = "dNUT"
    expression = "miFunc(!NUT2d!, !tyrplus!, !avplus!, !ha!)"
    codeblock = """def miFunc(miNut2, mipot, midisp, misup):
        sumtDMdNUT = numpy.sum([r[0] for r in arcpy.da.SearchCursor(fc,["avplus", "NUT2d"], where_clause="NUT2d like '" + miNut2 + "'")])   
        return sumtDMdNUT"""
    try:
        arcpy.CalculateField_management(fc, fieldName1, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

## surface stats  
import os
import arcpy
import numpy
folderPath = r"E:\new_shrub\Available" 
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 

fcLst = arcpy.ListFeatureClasses()
for fc in fcLst:
    fieldName2 = "haNUT"
    expression = "miFunc(!NUT2d!, !tyrplus!, !avplus!, !ha!)"
    codeblock = """def miFunc(miNut2, mipot, midisp, misup):
        sumtDMdNUT = numpy.sum([r[0] for r in arcpy.da.SearchCursor(fc,["ha", "NUT2d"], where_clause="NUT2d like '" + miNut2 + "'")])   
        return sumtDMdNUT"""
    try:
        arcpy.CalculateField_management(fc, fieldName2, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

## Change of name 
import arcpy
arcpy.env.workspace=r"E:\Available" 
arcpy.env.overwriteOutput = True 

featureClasses = arcpy.ListFeatureClasses()

for fc in featureClasses:
    fieldName = "thayrplus"
    try:
        arcpy.AddField_management(fc,fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "") 
        expression = 'float(!tyrplus!)'
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3")
    except:
        print fc
        continue

## dropfields
import arcpy
import os
import glob

arcpy.env.workspace = r"E:\Available" 

fclst = arcpy.ListFeatureClasses()
arcpy.env.overwriteOutput = True

for fc in fclst:
    fcName = fc
    #print(fc)
    arcpy.env.overwriteOutput = True
    output = fc.split(".shp")[0] +"_drop.shp"
    print output
    out_workspace = r"E:\Available" 
    out_featureclass = os.path.join(out_workspace, 
                                    os.path.splitext(output)[0])
    print out_featureclass
    dropFields = ["tyrplus","pNUT", "dNUT", "haNUT"]
    try:
        arcpy.CopyFeatures_management(fc, out_featureclass)
        arcpy.DeleteField_management(out_featureclass, dropFields)
    except:
        print fc + "bad"
        continue

#### COMPARE TO OTHER LAYERS 
import arcpy
import os
import glob

arcpy.env.workspace = r"E:\comparison

fclst = arcpy.ListFeatureClasses()
arcpy.env.overwriteOutput = True


for fc in fclst:
    fcName = fc
    #print(fc)
    arcpy.env.overwriteOutput = True
    output = fc.split(".shp")[0] +"_drop.shp"
    print output
    out_workspace = r"E:\comparison
    out_featureclass = os.path.join(out_workspace, 
                                    os.path.splitext(output)[0])
    print out_featureclass
    dropFields = ["Join_Count","TARGET_FID", "I_orcdrc01", "I_pes"]
    try:
        arcpy.CopyFeatures_management(fc, out_featureclass)
        arcpy.DeleteField_management(out_featureclass, dropFields)
    except:
        print fc + "bad"
        continue


## costs in enerbioscrub (spain coefficients)
import arcpy
arcpy.env.workspace=r"E:\new_shrub\Available\enerbioscrub"
arcpy.env.overwriteOutput = True 

featureClasses = arcpy.ListFeatureClasses()

for fc in featureClasses:
    inTable = fc
    coef1 = 47.36292204
    coef2 = 0.0299220385
    fieldName = "cost"
    slope_field = "slope"
    arcpy.AddField_management(fc,"cost","FLOAT","", "", "", "cost", "NULLABLE", "NON_REQUIRED", "") 
    #expression = 'float(float(' + str(coef1) + ') - float(!avplus!* ' + str(coef2) + '))'
    #expression = '1'
    expression = "IgnoreZero(float(!avplus!), float(!slope!), float(coef1), float(coef2))"
    codeblock = """def IgnoreZero(val, valSlope, c1, c2):
       if (val==0):
           return 0
       else:
           r=c1 - val * c2
           if (valSlope>20):
               return r*1.3
           else:   
               return r"""
    arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3", codeblock)

##
import os
import arcpy
import numpy
folderPath = r"E:\new_shrub\Available\enerbioscrub" 
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 

fcLst = arcpy.ListFeatureClasses()

## potential stats: check by CORINE code = MEAN (tyrplus/ ha)  
for fc in fcLst:
    fieldName4 = "pha"
    arcpy.AddField_management(fc,fieldName4,"FLOAT","", "", "", fieldName4, "NULLABLE", "NON_REQUIRED", "")
    expression = 'float(!tyrplus!/!ha!)'
    try:
        arcpy.CalculateField_management(fc, fieldName4, expression, "PYTHON_9.3")
    except:
        print fc
        continue

import os
import arcpy
import numpy
folderPath = r"E:\new_shrub\Available\enerbioscrub" 
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 

fcLst = arcpy.ListFeatureClasses()
## available stats: check by CORINE code = MEAN (avplus/ ha)  

for fc in fcLst:
    fieldName4 = "dha"
    arcpy.AddField_management(fc,fieldName4,"FLOAT","", "", "", fieldName4, "NULLABLE", "NON_REQUIRED", "")
    expression = 'float(!avplus!/!ha!)'
    try:
        arcpy.CalculateField_management(fc, fieldName4, expression, "PYTHON_9.3")
    except:
        print fc
        continue

import os
import arcpy
import numpy
folderPath = r"E:\new_shrub\Available\enerbioscrub" 
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 

fcLst = arcpy.ListFeatureClasses() 
## potential stats: check by CORINE code = MEAN (tyrplus/ ha)  
for fc in fcLst:
    fieldName = "phaCORINE"
    arcpy.AddField_management(fc,fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "")
    expression = "miFunc(!code_12!, !pha!)"
    codeblock = """def miFunc(miCORINE, mipotha):
        meanpCORINE = numpy.mean([r[0] for r in arcpy.da.SearchCursor(fc,["pha", "code_12"], where_clause="code_12 like '" + miCORINE + "'")])   
        return meanpCORINE"""
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

import os
import arcpy
import numpy
folderPath = r"E:\new_shrub\Available\enerbioscrub" 
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 

fcLst = arcpy.ListFeatureClasses() 
## available stats: check by CORINE code = MEAN (avplus/ ha)  
for fc in fcLst:
    fieldName = "dhaCORINE"
    arcpy.AddField_management(fc,fieldName,"FLOAT","", "", "", fieldName, "NULLABLE", "NON_REQUIRED", "")
    expression = "miFunc(!code_12!, !dha!)"
    codeblock = """def miFunc(miCORINE, mipotha):
        meanpCORINE = numpy.mean([r[0] for r in arcpy.da.SearchCursor(fc,["dha", "code_12"], where_clause="code_12 like '" + miCORINE + "'")])   
        return meanpCORINE"""
    try:
        arcpy.CalculateField_management(fc, fieldName, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

### WRITE TO EXCEL FILE 
import arcpy
import os
import itertools
import csv
import numpy
folderPath = r"E:\comparison" 
arcpy.env.workspace = folderPath
 
nut_temp=""
fcLst = arcpy.ListFeatureClasses()

for fc in fcLst:
    nut_temp=""
    #print(os.path.join(root, fc.split(".shp")[0]))    
    outname = fc.split(".shp")[0] +"_stats.csv" 
    fullPath = os.path.join(folderPath, outname)
    print fullPath
    csvLocation = fullPath
    with open(csvLocation,'wb') as openCSV:
        a = csv.writer(openCSV)
        #message = [['code_12','phaCORINE','pot','available']]
        message = [['code_12','phaCORINE']] # only text message as header
        a.writerows(message)
        try:
            #fields = ["code_12", "phaCORINE", "dhaCORINE", "haCORINE"]
            fields = ["code_12", "phaCORINE"]
            with arcpy.da.SearchCursor(fc, fields) as cursor:
                for row in cursor:
                    if row[0]!=nut_temp:
                        #message = [[row[0],row[1],row[2],row[3]]] # only text message as header
                        message = [[row[0],row[1]]] # only text message as header
                        a.writerows(message)
                    nut_temp=row[0]
        except:
            print fc
            continue

import arcpy
import os
import itertools
import csv
import numpy
folderPath = r"E:\new_shrub\Available\enerbioscrub" 
arcpy.env.workspace = folderPath
 
nut_temp=""
fcLst = arcpy.ListFeatureClasses()

for fc in fcLst:
    nut_temp=""
    #print(os.path.join(root, fc.split(".shp")[0]))    
    outname = fc.split(".shp")[0] +"_statsav.csv" 
    fullPath = os.path.join(folderPath, outname)
    print fullPath
    csvLocation = fullPath
    with open(csvLocation,'wb') as openCSV:
        a = csv.writer(openCSV)
        #message = [['code_12','dhaCORINE','pot','available']]
        message = [['code_12','dhaCORINE']] # only text message as header
        a.writerows(message)
        try:
            #fields = ["code_12", "phaCORINE", "dhaCORINE", "haCORINE"]
            fields = ["code_12", "dhaCORINE"]
            with arcpy.da.SearchCursor(fc, fields) as cursor:
                for row in cursor:
                    if row[0]!=nut_temp:
                        #message = [[row[0],row[1],row[2],row[3]]] # only text message as header
                        message = [[row[0],row[1]]] # only text message as header
                        a.writerows(message)
                    nut_temp=row[0]
        except:
            print fc
            continue


## available stats   ********* SUM STATS *******

import os
import arcpy
import numpy
folderPath = r"E:\new_shrub\Available" 
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 

fcLst = arcpy.ListFeatureClasses()

for fc in fcLst:
    fieldName1 = "dNUT"
    expression = "miFunc(!NUT2d!, !tyrplus!, !avplus!, !ha!)"
    codeblock = """def miFunc(miNut2, mipot, midisp, misup):
        sumtDMdNUT = numpy.sum([r[0] for r in arcpy.da.SearchCursor(fc,["avplus", "NUT2d"], where_clause="NUT2d like '" + miNut2 + "'")])   
        return sumtDMdNUT"""
    try:
        arcpy.CalculateField_management(fc, fieldName1, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

## surface stats
import os
import arcpy
import numpy
folderPath = r"E:\new_shrub\Available" 
arcpy.env.workspace=folderPath
arcpy.env.overwriteOutput = True 

fcLst = arcpy.ListFeatureClasses()

for fc in fcLst:
    fieldName2 = "haNUT"
    expression = "miFunc(!NUT2d!, !tyrplus!, !avplus!, !ha!)"
    codeblock = """def miFunc(miNut2, mipot, midisp, misup):
        sumtDMdNUT = numpy.sum([r[0] for r in arcpy.da.SearchCursor(fc,["ha", "NUT2d"], where_clause="NUT2d like '" + miNut2 + "'")])   
        return sumtDMdNUT"""
    try:
        arcpy.CalculateField_management(fc, fieldName2, expression, "PYTHON_9.3", codeblock)
    except:
        print fc
        continue

## (draft) attempt to run zonal statistics in a way that the field would automatically be fitted into the shapefile attribute table
for fc in features:
    def add_zonal_field(features, zone_field, input_raster, field_name, field_type, stat):
        arcpy.AddField_management(features, field_name, field_type)
        if arcpy.Exists("zonal_table"):
            try:
                arcpy.Delete_management("zonal_table")
            except:
                arcpy.AddError("Unable to clear temp table")
                sys.exit(-1)
        arcpy.AddMessage("Performing zonal statistics: " + field_name + " in " + features)
        zonal_table = ZonalStatisticsAsTable(features,zone_field, input_raster, "zonal_table", "DATA", stat)
        arcpy.AddMessage("Digesting " + stat + " from zonal table")
        stat_dict = {}

        with arcpy.da.SearchCursor(zonal_table,[zone_field,stat]) as cursor:
            for row in cursor:
                stat_dict[row[0]] = row[1]
        arcpy.AddMessage("Calculating " + field_name + "in " + features)

        with arcpy.da.UpdateCursor(features, [zone_field, field_name]) as cursor2:
            for row2 in cursor2:
                row2[1] = stat_dict[row2[0]]
                cursor2.updateRow(row2)
            return add_zonal_field
            
      
